<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>平滑加权轮询 on T1ck1ng's Blog</title><link>https://blog.rm-rf.icu/categories/%E5%B9%B3%E6%BB%91%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2/</link><description>Recent content in 平滑加权轮询 on T1ck1ng's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 09 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.rm-rf.icu/categories/%E5%B9%B3%E6%BB%91%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2/index.xml" rel="self" type="application/rss+xml"/><item><title>平滑加权轮询算法</title><link>https://blog.rm-rf.icu/p/%E5%B9%B3%E6%BB%91%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95/</link><pubDate>Thu, 09 Feb 2023 00:00:00 +0000</pubDate><guid>https://blog.rm-rf.icu/p/%E5%B9%B3%E6%BB%91%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95/</guid><description>&lt;img src="https://typora-mine.oss-cn-beijing.aliyuncs.com/typora/image-20230216204449307.png" alt="Featured image of post 平滑加权轮询算法" />&lt;h1 id="平滑加权轮询算法">平滑加权轮询算法&lt;/h1>
&lt;h2 id="0x01-轮询">0x01 轮询&lt;/h2>
&lt;p>假设现在有三台服务器（A、B、C），并配置了负载均衡来进行轮询，也就是让客户端发送的请求依次发送给A、B、C。则请求情况是：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">graph LR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">A(A)--&amp;gt;B(B)--&amp;gt;C(C)--&amp;gt;D(A)--&amp;gt;E(B)--&amp;gt;F(C)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但是实际中会存在服务器性能不一的问题，比如A服务器性能强，所以它需要处理更多的请求，因此需求的情况是：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">graph LR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">a1(A)--&amp;gt;a2(A)--&amp;gt;b1(B)--&amp;gt;c1(C)--&amp;gt;a4(A)--&amp;gt;a47(A)--&amp;gt;b2(B)--&amp;gt;c2(C)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而对应到代码中，就是给每台服务器设置一个权重，如：A（2）、B（1）、C（1），让请求根据权重发送给服务器，这样一来，就可以实现上述中的需求情况，此时的权重是静态的。&lt;/p>
&lt;h2 id="0x02-新的问题">0x02 新的问题&lt;/h2>
&lt;p>但在实际情况中，为了实现细颗粒度的需求，权重一般是一个很大的数值，如A(500)、B(1)、C(1)，此时轮询就会变成这样：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">graph LR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1(A)--&amp;gt;2(A)--&amp;gt;3(A)--&amp;gt;4(A)--&amp;gt;5(A)--&amp;gt;6(......)--&amp;gt;7(B)--&amp;gt;8(C)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>也就形成了新的问题——单点过热。&lt;/p>
&lt;p>这时静态权重就显示出了它的局限性，就需要通过一系列的算法计算出动态权重，并通过动态权重来进行&lt;code>平滑轮询&lt;/code>。&lt;/p></description></item></channel></rss>